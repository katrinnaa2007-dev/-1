Лабораторная работа №3
Работа в VS Code со структурами данных
«бинарная_биноминальная куча/куча Фибоначчи/хеш-таблицы»

Цель работы
Изучить особенности структур данных «бинарная куча», «биномиальная куча», «куча Фибоначчи» и «хеш-таблицы». Приобрести практические навыки их реализации на языках программирования Python, C++ и Java. Провести сравнительный анализ представлений этих структур на разных языках.

1. Бинарная куча
Это полное двоичное дерево, где все уровни, кроме последнего, заполнены полностью, а последний — слева направо. Узлы упорядочены: каждый родитель не больше (min-heap) или не меньше (max-heap) своих потомков.
Python: Реализуется через список и модуль heapq, который поддерживает только min-heap. Для max-heap значения инвертируют. Элементы добавляются (heappush) и извлекаются (heappop) с сохранением свойств кучи.
C++: Используется std::priority_queue или std::vector. При добавлении элемент помещается в конец и "поднимается", а при удалении минимума корень заменяется последним элементом и куча "просеивается".
Java: Класс PriorityQueue скрывает внутренний массив. Элементы добавляются методом add/offer, а минимум извлекается poll.

2. Биномиальная куча
Состоит из набора биномиальных деревьев разного размера, где ключ родителя не больше ключей потомков. Стандартных реализаций в Python, C++ и Java нет, поэтому её создают вручную через классы узлов и кучи.
Основные операции:
insert(key): Создаёт дерево степени 0 и добавляет его в список корней.
getMin(): Проходит по корням и находит минимум.
merge(): Объединяет две кучи, сливая деревья с одинаковой степенью.
extractMin(): Удаляет минимальный корень, а его дочерние деревья добавляет в кучу.

3. Куча Фибоначчи
Состоит из деревьев произвольной формы, удовлетворяющих свойству min-heap. Деревья организованы в циклический двусвязный список корней, что позволяет эффективно выполнять операции.
Реализация: Во всех языках (Python, C++, Java) требуется ручная реализация на основе классов для узлов и кучи. Ключевые особенности — использование циклических списков и отложенные операции (например, объединение деревьев происходит только при необходимости).

4. Хеш-таблица
Структура для хранения пар «ключ-значение», обеспечивающая быстрый доступ. Ключ хешируется в индекс массива. Коллизии решаются методом цепочек или открытой адресации.
Python: Можно использовать встроенный dict или реализовать вручную. В самописной версии массив содержит «бакеты», а для разрешения коллизий применяют цепочки, линейное пробирование или двойное хеширование.
C++: Используется std::unordered_map. Также можно реализовать вручную на основе массива списков (метод цепочек).
Java: Применяются классы HashMap или Hashtable. Основные операции: put (вставка), get (получение), remove (удаление) и containsKey (проверка наличия ключа).

Сравнительная таблица особенностей реализации
Структура данных	\ Python	\ C++	\ Java
Бинарная куча	\Модуль heapq, простота использования	\Полный контроль, шаблонные классы\	Объектно-ориентированный подход, дженерики
Биномиальная куча\	Отсутствует в стандартной библиотеке\	Сложная реализация с указателями\	Сложность управления памятью
Куча Фибоначчи\	Нет в стандартной библиотеке\	Высокая производительность\	Автоматическое управление памятью
Хеш-таблицы\	dict - встроенный тип	s\td::unordered_map\	HashMap, Hashtable

Особенности формирования структур данных
Python:
Динамическая типизация упрощает реализацию
Встроенные структуры оптимизированы
Меньше контроля над памятью
C++:
Максимальный контроль над памятью и производительностью
Шаблонное программирование для универсальности
Сложность реализации и отладки
Java:
Строгая типизация с дженериками
Автоматическое управление памятью
Богатая стандартная библиотека

Выводы
Каждый язык программирования предоставляет различные уровни абстракции для работы со структурами данных.
Python предлагает наиболее простой и быстрый способ работы со встроенными структурами.
C++ обеспечивает максимальную производительность и контроль, но требует больше усилий для реализации.
Java находит баланс между производительностью и простотой использования благодаря строгой типизации и автоматическому управлению памятью.
Выбор языка и способа реализации зависит от конкретных требований проекта: производительность, скорость разработки или потребление памяти.
