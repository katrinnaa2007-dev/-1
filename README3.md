Лабораторная работа №3
Работа в VS Code со структурами данных
«бинарная_биноминальная куча/куча Фибоначчи/хеш-таблицы»

1. Бинарная куча
Это полное двоичное дерево, где все уровни, кроме последнего, заполнены полностью, а последний — слева направо. Узлы упорядочены: каждый родитель не больше (min-heap) или не меньше (max-heap) своих потомков.
Python: Реализуется через список и модуль heapq, который поддерживает только min-heap. Для max-heap значения инвертируют. Элементы добавляются (heappush) и извлекаются (heappop) с сохранением свойств кучи.
C++: Используется std::priority_queue или std::vector. При добавлении элемент помещается в конец и "поднимается", а при удалении минимума корень заменяется последним элементом и куча "просеивается".
Java: Класс PriorityQueue скрывает внутренний массив. Элементы добавляются методом add/offer, а минимум извлекается poll.

2. Биномиальная куча
Состоит из набора биномиальных деревьев разного размера, где ключ родителя не больше ключей потомков. Стандартных реализаций в Python, C++ и Java нет, поэтому её создают вручную через классы узлов и кучи.
Основные операции:
insert(key): Создаёт дерево степени 0 и добавляет его в список корней.
getMin(): Проходит по корням и находит минимум.
merge(): Объединяет две кучи, сливая деревья с одинаковой степенью.
extractMin(): Удаляет минимальный корень, а его дочерние деревья добавляет в кучу.

3. Куча Фибоначчи
Состоит из деревьев произвольной формы, удовлетворяющих свойству min-heap. Деревья организованы в циклический двусвязный список корней, что позволяет эффективно выполнять операции.
Реализация: Во всех языках (Python, C++, Java) требуется ручная реализация на основе классов для узлов и кучи. Ключевые особенности — использование циклических списков и отложенные операции (например, объединение деревьев происходит только при необходимости).

4. Хеш-таблица
Структура для хранения пар «ключ-значение», обеспечивающая быстрый доступ. Ключ хешируется в индекс массива. Коллизии решаются методом цепочек или открытой адресации.
Python: Можно использовать встроенный dict или реализовать вручную. В самописной версии массив содержит «бакеты», а для разрешения коллизий применяют цепочки, линейное пробирование или двойное хеширование.
C++: Используется std::unordered_map. Также можно реализовать вручную на основе массива списков (метод цепочек).
Java: Применяются классы HashMap или Hashtable. Основные операции: put (вставка), get (получение), remove (удаление) и containsKey (проверка наличия ключа).
