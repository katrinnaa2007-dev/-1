3. Практическая часть
3.1 Реализация на Python
Мультисписок (вложенный список)
python
# Создание и работа с вложенным списком
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Добавление элемента
nested_list.append([10, 11, 12])

# Удаление элемента
nested_list.pop(1)

# Изменение элемента
nested_list[0][1] = 99

# Преобразование вложенного списка в плоский
def flatten_list(nested):
    flat_list = []
    for sublist in nested:
        if isinstance(sublist, list):
            flat_list.extend(flatten_list(sublist))
        else:
            flat_list.append(sublist)
    return flat_list

# Альтернативное решение
groups = [['Hong', 'Ryan'], ['Andry', 'Ross'], ['Mike', 'Smith']]
names = []
for group in groups:
    names.extend(group)
Очередь и Дек
python
from collections import deque

# Реализация очереди
class Queue:
    def __init__(self):
        self.items = deque()
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        return self.items.popleft() if self.items else None
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)

# Реализация дека
class Deque:
    def __init__(self):
        self.items = deque()
    
    def add_front(self, item):
        self.items.appendleft(item)
    
    def add_rear(self, item):
        self.items.append(item)
    
    def remove_front(self):
        return self.items.popleft() if self.items else None
    
    def remove_rear(self):
        return self.items.pop() if self.items else None
    
    def is_empty(self):
        return len(self.items) == 0

# Пример использования
q = Queue()
q.enqueue("task1")
q.enqueue("task2")
print(q.dequeue())  # task1

d = Deque()
d.add_front(1)
d.add_rear(2)
print(d.remove_front())  # 1
Приоритетная очередь
python
import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0
    
    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1
    
    def pop(self):
        if self._queue:
            return heapq.heappop(self._queue)[-1]
        return None
    
    def is_empty(self):
        return len(self._queue) == 0

# Пример использования
pq = PriorityQueue()
pq.push("high priority task", 3)
pq.push("low priority task", 1)
pq.push("medium priority task", 2)

while not pq.is_empty():
    print(pq.pop())
3.2 Реализация на C++
Двусвязный список (мультисписок)
cpp
#include <iostream>
using namespace std;

template<typename T>
struct Node {
    T data;
    Node* prev;
    Node* next;
    
    Node(T value) : data(value), prev(nullptr), next(nullptr) {}
};

template<typename T>
class DoublyLinkedList {
private:
    Node<T>* head;
    Node<T>* tail;
    int size;
    
public:
    DoublyLinkedList() : head(nullptr), tail(nullptr), size(0) {}
    
    void push_back(T value) {
        Node<T>* newNode = new Node<T>(value);
        if (!head) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
        size++;
    }
    
    void push_front(T value) {
        Node<T>* newNode = new Node<T>(value);
        if (!head) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
        size++;
    }
    
    void pop_back() {
        if (!tail) return;
        Node<T>* temp = tail;
        tail = tail->prev;
        if (tail) tail->next = nullptr;
        else head = nullptr;
        delete temp;
        size--;
    }
    
    void display() {
        Node<T>* current = head;
        while (current) {
            cout << current->data << " ";
            current = current->next;
        }
        cout << endl;
    }
    
    ~DoublyLinkedList() {
        while (head) {
            Node<T>* temp = head;
            head = head->next;
            delete temp;
        }
    }
};
Очередь и Дек
cpp
#include <queue>
#include <deque>
#include <iostream>
using namespace std;

// Пример использования std::queue
void queue_example() {
    queue<string> q;
    q.push("Task 1");
    q.push("Task 2");
    q.push("Task 3");
    
    while (!q.empty()) {
        cout << "Processing: " << q.front() << endl;
        q.pop();
    }
}

// Пример использования std::deque
void deque_example() {
    deque<int> dq;
    dq.push_back(1);
    dq.push_front(0);
    dq.push_back(2);
    
    cout << "Front: " << dq.front() << endl;
    cout << "Back: " << dq.back() << endl;
    
    while (!dq.empty()) {
        cout << dq.front() << " ";
        dq.pop_front();
    }
    cout << endl;
}
Приоритетная очередь
cpp
#include <queue>
#include <iostream>
#include <string>
using namespace std;

struct Task {
    string name;
    int priority;
    
    // Перегрузка оператора < для сравнения приоритетов
    bool operator<(const Task& other) const {
        return priority < other.priority; // Максимальная куча
    }
};

void priority_queue_example() {
    priority_queue<Task> pq;
    
    pq.push({"Low priority", 1});
    pq.push({"High priority", 3});
    pq.push({"Medium priority", 2});
    
    while (!pq.empty()) {
        Task task = pq.top();
        cout << "Processing: " << task.name 
             << " (Priority: " << task.priority << ")" << endl;
        pq.pop();
    }
}
3.3 Реализация на Java
Двусвязный список
java
public class DoublyLinkedList<T> {
    private class Node {
        T data;
        Node prev;
        Node next;
        
        Node(T data) {
            this.data = data;
            this.prev = null;
            this.next = null;
        }
    }
    
    private Node head;
    private Node tail;
    private int size;
    
    public DoublyLinkedList() {
        head = null;
        tail = null;
        size = 0;
    }
    
    public void addFirst(T data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = tail = newNode;
        } else {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        }
        size++;
    }
    
    public void addLast(T data) {
        Node newNode = new Node(data);
        if (tail == null) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
        size++;
    }
    
    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
    
    public int size() {
        return size;
    }
}
Очередь и Дек
java
import java.util.*;

public class QueueDequeExample {
    // Пример использования Queue
    public static void queueExample() {
        Queue<String> queue = new LinkedList<>();
        queue.add("Task 1");
        queue.add("Task 2");
        queue.add("Task 3");
        
        while (!queue.isEmpty()) {
            System.out.println("Processing: " + queue.poll());
        }
    }
    
    // Пример использования Deque
    public static void dequeExample() {
        Deque<Integer> deque = new ArrayDeque<>();
        deque.addFirst(1);
        deque.addLast(2);
        deque.addFirst(0);
        
        System.out.println("First: " + deque.getFirst());
        System.out.println("Last: " + deque.getLast());
        
        while (!deque.isEmpty()) {
            System.out.print(deque.removeFirst() + " ");
        }
        System.out.println();
    }
}
Приоритетная очередь
java
import java.util.*;

class Task implements Comparable<Task> {
    String name;
    int priority;
    
    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    @Override
    public int compareTo(Task other) {
        return Integer.compare(other.priority, this.priority); // Максимальная куча
    }
    
    @Override
    public String toString() {
        return name + " (Priority: " + priority + ")";
    }
}

public class PriorityQueueExample {
    public static void main(String[] args) {
        PriorityQueue<Task> pq = new PriorityQueue<>();
        
        pq.add(new Task("Low priority task", 1));
        pq.add(new Task("High priority task", 3));
        pq.add(new Task("Medium priority task", 2));
        
        while (!pq.isEmpty()) {
            System.out.println("Processing: " + pq.poll());
        }
    }
}
