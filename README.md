Лабораторная работа №4
Работа в VS Code со структурами данных «деревья/графы»

Цель работы:
Изучить основы структур данных «дерево» и «граф», их представление в языках программирования Python, C++, Java, а также освоить алгоритмы работы с ними, включая алгоритм Дейкстры для поиска кратчайшего пути в графе.

1) Теоретические основы структур данных
Дерево
Дерево представляет собой иерархическую структуру данных, состоящую из узлов. Ключевые особенности:

Каждый узел имеет ровно одного родителя, за исключением корневого узла, у которого родителя нет.

Узел может иметь ноль или более дочерних узлов.

Узлы без дочерних элементов называются листьями.
Эта модель широко применяется для представления файловых систем, организационных структур и других иерархических данных.

Граф
Граф — это нелинейная структура данных, состоящая из множества вершин (узлов) и соединяющих их рёбер.

Формально граф задается как G = (U, E), где U — множество вершин, а E — множество рёбер (каждое ребро можно представить парой [x, y]).

Графы классифицируются по типу рёбер: они могут быть ориентированными (направленными) или неориентированными, а также взвешенными (с весом) или невзвешенными.

2) Реализация бинарного дерева
Бинарное дерево в рассмотренных языках программирования реализуется с помощью узла, который хранит ключ и ссылки на левого и правого потомка. Основные операции (вставка, поиск, удаление) приводятся как в рекурсивной, так и в итеративной форме.

В Python для этого создается класс Node с атрибутами key, left и right, где отсутствие поддерева обозначается значением None. Класс Tree содержит корень (root), а основные операции реализуются двумя способами, с использованием вспомогательных функций (например, find_min для операции удаления).

В Java используется внутренний статический класс Node с полями key, left, right. Класс Tree содержит поле root. Вставка, например, реализована с рекурсивным вспомогательным методом doInsert и альтернативным итеративным спуском, учитывающим случаи пустого дерева и дубликатов ключей.

В C++ узел часто объявляется как структура TNode с указателями Left и Right, рекомендуется инициализация через списки и использование nullptr. Класс TTree снабжается деструктором для рекурсивного освобождения памяти, а для нерекурсивной вставки применяется элегантное решение через указатель на указатель (TNode**).

3) Реализация графов и алгоритма Дейкстры
Алгоритм Дейкстры для поиска кратчайших путей реализуется на всех трех языках с использованием приоритетной очереди (мин-кучи) и поддерживает разные представления графа, такие как матрица смежности и список смежности.

Общая схема алгоритма Дейкстры:

Инициализация: Все расстояния устанавливаются в бесконечность, кроме расстояния до стартовой вершины, которое равно 0. Стартовая вершина помещается в приоритетную очередь.

Основной цикл: Пока очередь не пуста, извлекается вершина с наименьшим текущим расстоянием.

Релаксация рёбер: Для каждого соседа текущей вершины вычисляется новое расстояние. Если оно меньше известного, то расстояние обновляется, и обновленная пара (расстояние, вершина) помещается в очередь.

Особенности реализаций:

Python: Граф представляется в виде словаря словарей, где ключ — вершина, а значение — словарь соседей и весов рёбер. Для приоритетной очереди используется модуль heapq. Расстояния инициализируются с помощью float('inf'). Алгоритм постоянно извлекает минимум и релаксирует исходящие рёбра, пропуская "устаревшие" пары в очереди, где расстояние уже не актуально.

C++: Граф моделируется как vector<vector<Edge>>, где Edge — структура с полями destination и weight. Приоритетная очередь (priority_queue) настраивается с компаратором greater для работы как мин-куча. Используется вектор dist для хранения текущих расстояний. Алгоритм аналогично пропускает устаревшие записи в очереди.

Java: При использовании списка смежности граф представляется как массив или список списков ArrayList<Edge>[], где Edge — класс, содержащий соседа (nbr) и вес (weight). Для очереди применяется PriorityQueue, которая использует компаратор, основанный на поле "вес от старта" (wsf) в классе Pair. В этой реализации также используется массив visited[] для отметки вершин, кратчайшее расстояние до которых уже найдено.

Сложность: Во всех реализациях сложность алгоритма составляет O((V+E) log V), где V — число вершин, а E — число рёбер. Это связано с тем, что операции с приоритетной очередью (вставка и извлечение) выполняются за логарифмическое время, и они выполняются для каждой вершины и каждого ребра.
